Question 1
*************************************************************

Design Pattern Template â€“ Strategy Pattern
Pattern Name
Strategy Pattern

Problem
In a payment processing system, there is a need to support multiple payment methods such as Credit Card, PayPal, and EFT. Hardcoding each payment option into the system leads to tight coupling and makes it difficult to extend or modify. There must be a way to allow easy integration of new payment methods without altering the core processing logic.

Motivation
The goal is to support different payment methods dynamically and allow developers to add new ones without changing existing logic. This promotes open/closed principle (open to extension, closed to modification), enhancing flexibility and maintainability.

Context
The application allows customers to choose a payment method during checkout. Each method requires different processing logic. New methods (e.g., cryptocurrency) may be introduced in the future. The same processing framework should support all methods without major changes.

Forces

Flexibility: Payment methods may change or grow over time.

Maintainability: Avoid modifying existing logic when adding new payment types.

Decoupling: Core payment process should not depend on specific implementations.

Consistency: All payment types should conform to a common interface.

Solution
Define a family of payment behaviors (strategies), encapsulate each one, and make them interchangeable. The client selects the desired strategy at runtime based on user choice. Each payment method implements a common interface.

Intent
Define a set of interchangeable algorithms or behaviors and encapsulate them, so they can be used independently without modifying the client code.

Collaborations

The Payment Context delegates payment execution to the selected Payment Strategy.

Each Payment Strategy (e.g., CreditCardPayment, PayPalPayment) implements the interface.

Developers can add new payment methods by creating new strategy classes.

Consequences
Benefits:

Easy to add new payment methods

Avoids large conditionals (e.g., if-else or switch statements)

Promotes separation of concerns

Complies with SOLID principles (especially Open/Closed Principle)

Drawbacks:

More classes to manage

Requires careful coordination when integrating new strategies

Implementation
Encapsulate each payment method in its own class that follows a shared interface. The main payment handler interacts only with the interface, not the specific payment method.

Known Uses

Payment systems in e-commerce platforms

Sorting algorithms in libraries

Input validation strategies

Game AI with different enemy behaviors

Related Pattern

Factory Method: Can be used to instantiate specific payment strategies based on runtime input.

Decorator: Can be combined with Strategy for additional processing features (e.g., logging, auditing).
